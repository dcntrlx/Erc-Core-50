ERC-1271: Standard Signature Validation Method for Contracts
created: 2018-07-25

Description: provides a standard way for any contracts to verify whether a signature on a behalf of a given contract is valid.

Smart contracts, unlike EOA doesnt have a private key, and thus an ability to sign messages. But sometimes we want to apply logic where smart contract want to sign message. Despite the fact that smart contract cannot sign messages, we can make a mechanism where smart contract can verify a signature considered to be valid.

```solidity
function isValidSignature(bytes32 _hash, bytes memory _signature) public view returns (bytes4 magicValue);
```

## Interface

```solidity
pragma solidity ^0.5.0;

contract ERC1271 {

  bytes4 constant internal MAGICVALUE = 0x1626ba7e; // bytes4(keccak256("isValidSignature(bytes32,bytes)")

  // Must return magic value 0x1626ba7e if signature is consididered to be valid for current hash. Otherwise must return 0x0. E.g. signature can be consididered valid if it valid signature of an owner of this contract.
  // Function must not modify state, and must allow external calls.
  function isValidSignature(bytes32 _hash, bytes memory _signature) public view returns (bytes4 magicValue);
}
```

`isValidSignature` can call arbitrary methods to validate a given signature
`isValidSignature()` should not be able to modify states in order to prevent attack vectors. 

>The specific return value is expected to be returned instead of a boolean in order to have stricter and simpler verification of a signature.

>This standard is fully backward compatible. It introduces a new method specifically for contract-based signatures, which does not conflict with existing EOA signature methods.

## Reference Implementation
> Simple example directly from ERC1271 a little extended with check example
### 1. The Signing Contract (e.g., Smart Wallet)
This contract implements the logic to verify a signature. In this example, it checks if the signature belongs to the contract's owner.

```solidity
function isValidSignature(bytes32 _hash, bytes calldata _signature) external override view returns (bytes4) {
    // 1. Recover the signer from the signature
    address signer = recoverSigner(_hash, _signature);
    
    // 2. Check if the signer is the owner
    if (signer == owner) {
        return 0x1626ba7e; // Success!
    } else {
        return 0xffffffff; // Fail
    }
}
```
*(Note: `recoverSigner` is a standard helper function using `ecrecover` to extract the address from `v, r, s` and making additional checks on validness of signature)*

### 2. The Verifying Contract (e.g., Exchange)
This contract asks the Smart Wallet if a signature is valid.

```solidity
function callERC1271isValidSignature(address _wallet, bytes32 _hash, bytes calldata _signature) external view {
    // 1. Call the wallet
    bytes4 result = IERC1271Wallet(_wallet).isValidSignature(_hash, _signature);
    
    // 2. Verify the magic value
    require(result == 0x1626ba7e, "Signature provided is invalid");
}
```

## Security Considerations
1.  **Gas Usage:** Since `isValidSignature` can run arbitrary code, it might consume a lot of gas. Verifiers should avoid hardcoding low gas limits, as this could cause valid signatures to fail.
2.  **Responsibility:** The implementing contract (the wallet) is the only one who  responsible for its own security. If it returns Valid for a bad signature, the consequences are catastrophic (e.g., funds stolen).
