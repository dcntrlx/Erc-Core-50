# [ERC165](https://eips.ethereum.org/EIPS/eip-165)
**Created**: 2018-01-23  
**Description**: 
- Standardizes the concept of interfaces and standardizes the identification (naming) of interfaces. 
- Creates a standard method to publish and detect what interfaces a smart contract implements.

**Motivation**: Add an easy way to check if contract implements an interface

### Identification(naming) of interfaces
We define the interface identifier as the XOR of all function selectors in the interface.
```
identifier = function1.selector ^ function2.selector;
```

### Contracts provides interfaces implemented
A contract that is compliant with ERC-165 shall implement the following interface:

```solidity
pragma solidity ^0.4.20;

interface ERC165 {
    /// @notice Query if a contract implements an interface
    /// @param interfaceID The interface identifier, as specified in ERC-165
    /// @dev Interface identification is specified in ERC-165. This function
    ///  uses less than 30,000 gas.
    /// @return `true` if the contract implements `interfaceID` and
    ///  `interfaceID` is not 0xffffffff, `false` otherwise
    function supportsInterface(bytes4 interfaceID) external view returns (bool);
}
```

**supportsInterface(bytes4 interfaceID)** function is the one which will provide an infromation whether contract implements an interface. It returns true if an interfaceId is implemented by the contract and false if an interfaceId otherwise


## Two phase interface implementation detection
1. Check if a contract implements ERC-165 (important for future compatibility and to establish protocol)
2. Check if a contract implements an interface
### How to Detect if a Contract Implements ERC-165
To detect if a contract implements ERC-165, perform the following checks:

1.  **STATICCALL** with `0x01ffc9a7` (ERC165 ID). Must return `true`.
2.  **STATICCALL** with `0xffffffff` (Invalid ID). Must return `false`.
> **Reasoning for checking 0xffffffff?**  
> It acts as a "negative control" to prevent false positives. If a contract has a fallback function that blindly returns `true` for everything, checking `0xffffffff` (which *must* return `false`) allows us to detect this and confirm the contract doesn't actually implement ERC-165 logic.

If both conditions are met, the contract implements ERC-165.
### How to Detect if a Contract Implements any Given Interface
1.  Check if it implements ERC-165 (using above steps).
2.  If yes, call `supportsInterface(interfaceID)`.
3.  If no, use old-fashioned methods (try-catch calls).
.
## Implementation Strategies
There are two main ways to implement `supportsInterface`:

**1. Mapping Approach (Storage)**
- Uses a `mapping(bytes4 => bool)`.
- **Pros**: Constant gas cost for queries (~586 gas).
- **Cons**: High initialization cost (20,000 gas per interface via SSTORE).
- Suitable for contracts with dynamic systems (like proxies or diamonds) where used interfaces can be added or removed after deployment.
- **Best for**: Contracts with huge amount of interfaces or dynamic systems


```solidity
mapping(bytes4 => bool) internal supportedInterfaces;

function supportsInterface(bytes4 interfaceID) external view returns (bool) {
    return supportedInterfaces[interfaceID];
}
```

> **Comparison in gas cost**
> When this EIP was created (2018), `SLOAD` was cheap (~200 gas). Today, a "cold" `SLOAD` costs 2100 gas.
> In the modern EVM, the **Pure Approach** is almost always cheaper. You would need to check ~70-100 interfaces for the Mapping approach to break even.
> **Mapping is now primarily useful for:** Dynamic systems (like Proxies/Diamonds) where interfaces are added/removed after deployment.

**2. Pure Approach (Computation)**
- Uses logical ORs and comparisons.
- **Pros**: Cheap initialization (no storage). Low gas for few interfaces (~236 gas).
- **Cons**: Gas cost increases linearly with the number of interfaces.
- **Best for**: Contracts with few interfaces.
```solidity
function supportsInterface(bytes4 interfaceID) external view returns (bool) {
    return interfaceID == this.supportsInterface.selector || // ERC165
           interfaceID == this.is2D.selector ^ this.skinColor.selector; // Other Interface
}
```

>**3. Hybrid Approach**
>- Uses logical ORs and comparisons for immutable interfaces, like ERC165 itself or other primary interfaces, lying under the contract(which will never change).
>- Uses a mapping for dynamic interfaces.
>- Combines the best of two approaches.
>- Also suitable for dynamic systems (like Proxies/Diamonds) where interfaces are added/removed after deployment.

```solidity
function supportsInterface(bytes4 interfaceID) external view returns (bool) {
   // 1. Check Hardcoded
   // Avoids SLOAD (2100 gas) for the most common checks
   if (interfaceID == this.supportsInterface.selector || // ERC165
       interfaceID == 0x80ac58cd) { // Example: ERC721
       return true;
   }

   // 2. Check Dynamic
   // Only pay the SLOAD cost for optional/dynamic interfaces
   return supportedInterfaces[interfaceID];
}
```

### Reference Implementation: The Detector (ERC165Query)
A helper contract checking the safely check interfaces using assembly (to handle reverts/invalid data).

```solidity
contract ERC165Query {
    bytes4 constant InvalidID = 0xffffffff;
    bytes4 constant ERC165ID = 0x01ffc9a7;

    function doesContractImplementInterface(address _contract, bytes4 _interfaceId) external view returns (bool) {
        uint256 success;
        uint256 result;

        // 1. Check ERC165 support
        (success, result) = noThrowCall(_contract, ERC165ID);
        if (success == 0 || result == 0) {
            return false;
        }

        // 2. Check InvalidID (must be false)
        (success, result) = noThrowCall(_contract, InvalidID);
        if (success == 0 || result != 0) {
            return false;
        }

        // 3. Check _interfaceId
        (success, result) = noThrowCall(_contract, _interfaceId);
        if (success == 1 && result == 1) {
            return true;
        }

        return false;
    }
    
    // Uses assembly staticcall to avoid reverts and handle raw data
    function noThrowCall(address _contract, bytes4 _interfaceId) constant internal returns (uint256 success, uint256 result) {
        bytes4 erc165ID = ERC165ID;
        assembly {
            let x := mload(0x40)               // Get free memory pointer
            mstore(x, erc165ID)                // Store selector
            mstore(add(x, 0x04), _interfaceId) // Store argument (padded)
            
            success := staticcall(
                30000,         // 30k gas limit
                _contract,     // Target address
                x,             // Input location
                0x24,          // Input length (36 bytes)
                x,             // Output location
                0x20           // Output length (32 bytes)
            )
            result := mload(x) // Read result
        }
    }
}
```