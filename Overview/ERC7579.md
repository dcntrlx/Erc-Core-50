# [ERC7579](https://eips.ethereum.org/EIPS/eip-7579)
**Created:** 2023.12.14
**Description:** A minimal standard for Modular Smart Accounts. It defines how a smart account (wallet) should interact with "Modules" (plugins), ensuring that a module built for one wallet works on any other wallet.

### Overview
ERC-7579 is the "USB-C" of smart accounts. Before this standard, if you built a "Social Recovery Module" for a Safe wallet, it wouldn't work on a Biconomy wallet. ERC-7579 standardizes the interfaces so that modules are interoperable.

It takes a **minimalist** approach. Unlike earlier attempts (like ERC-6900) that tried to define the entire OS of the wallet, ERC-7579 just defines the ports.

### The "Why": The App Store Moment
To understand ERC-7579, think of a Smart Account as a smartphone.
*   **Pre-7579:** Every phone manufacturer wrote their own OS and their own apps. A calculator app for Phone A wouldn't work on Phone B.
*   **Post-7579:** The phone (Account) is just a platform. Developers build apps (Modules) that run on any phone.

This allows for an "App Store" of features:
1.  **Validators:** "FaceID" for your wallet (Passkeys, Multi-sig, Session Keys).
2.  **Executors:** "Automation" scripts (Auto-pay, DCA).
3.  **Hooks:** "Firewall" rules (Spend limits, Whitelists).

### Core Concepts

#### 1. Module Types
The standard defines specific roles for modules:
*   **Validators:** Modules that verify signatures. They answer the question: *"Is this user allowed to do this?"*
*   **Executors:** Modules that can execute transactions on behalf of the account. They answer: *"What should be done?"*
*   **Hooks:** Modules that run before or after a transaction. They act as safety guards.

#### 2. Execution Modes
The account must support specific ways to execute commands, ensuring modules can do their job without compromising security.
*   **`execute`**: Standard call. The account calls an external contract.
*   **`executeFromExecutor`**: A trusted module tells the account to do something.

### Technical Summary

| Feature | Monolithic Account | **ERC-7579 Modular Account** |
| :--- | :--- | :--- |
| **Features** | Hardcoded (upgrades are hard) | Plugins (add/remove anytime) |
| **Interoperability** | Low (Vendor Lock-in) | High (Universal Modules) |
| **Complexity** | High (All logic in one place) | Low (Logic split into small modules) |

### Specification Interface
The standard requires the account to implement specific functions to manage modules.

1.  **`installModule`**
    ```solidity
    function installModule(
        uint256 moduleTypeId,
        address module,
        bytes calldata initData
    ) external payable;
    ```
    Installs a module. The `moduleTypeId` defines if it's a Validator (1), Executor (2), etc. The `initData` is passed to the module to set it up.

2.  **`executeFromExecutor`**
    ```solidity
    function executeFromExecutor(
        ModeCode mode,
        bytes calldata executionCalldata
    ) external payable returns (bytes[] memory returnData);
    ```
    Allows an installed Executor module to trigger a transaction. The `ModeCode` is a packed bytes32 that defines how the execution should happen (single call, batch call, delegatecall, etc.).

3.  **`accountId`**
    ```solidity
    function accountId() external view returns (string memory accountImplementationId);
    ```
    Returns a unique identifier for the account implementation (e.g., "biconomy.v2.0.0"). This helps modules know exactly which "phone" they are running on if they need implementation-specific tweaks.
