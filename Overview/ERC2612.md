# ERC2612
Created: 2020-04  
Description: An extension for ERC-20 tokens that allows approvals to be made via signatures (EIP-712), enabling "gasless" transactions where a relayer pays the gas fees.

## Core Concepts
### The Problem: Dual Transaction Requirement
Standard ERC-20 tokens require two transactions to interact with a contract (e.g., Uniswap):
1.  Approve: The user sends a transaction to allow the contract to spend their tokens. (Costs gas, requires ETH).
2.  TransferFrom: The user sends a second transaction to execute the logic (swap/deposit).

This creates friction as users require ETH to interact with the token and must wait for two transactions.

### The Solution: Permit
ERC-2612 adds a permit function.
1.  Sign: A message is signed off-chain approving a spender. (Free, no ETH needed).
2.  Submit: The signature is sent to a Relayer (or the Contract itself).
3.  Execute: The Relayer calls permit on the token contract using the signature. The token contract verifies the signature and updates the allowance.
4.  Transfer: The Relayer (or Contract) can immediately call transferFrom in the same transaction.

Result: 1 Transaction (paid by Relayer) instead of 2.

## Methods

### permit
```solidity
function permit(
    address owner, 
    address spender, 
    uint256 value, 
    uint256 deadline, 
    uint8 v, 
    bytes32 r, 
    bytes32 s
) external;
```
-   **owner**: The token holder.
-   **spender**: The address getting approval.
-   **value**: Amount to approve.
-   **deadline**: Timestamp after which the signature is invalid.
-   **v, r, s**: The EIP-712 signature components.

### nonces
```solidity
function nonces(address owner) external view returns (uint256);
```
-   Returns the current nonce for an owner. Used to prevent replay attacks.

### DOMAIN_SEPARATOR
```solidity
function DOMAIN_SEPARATOR() external view returns (bytes32);
```
-   Returns the EIP-712 domain separator. Ensures signatures are unique to this specific contract and chain ID.

## Implementation Details

### The EIP-712 Struct
The signature must be generated for the following struct:
```solidity
Permit(
    address owner,
    address spender,
    uint256 value,
    uint256 nonce,
    uint256 deadline
)
```

### Verification Logic
Inside permit:
1.  Check block.timestamp <= deadline.
2.  Construct the message hash using DOMAIN_SEPARATOR and the struct hash.
3.  Recover the signer using ecrecover.
4.  Check signer == owner.
5.  Check owner != address(0).
6.  Check nonce matches nonces[owner].
7.  **If valid**:
    -   Increment nonces[owner].
    -   Set allowance[owner][spender] = value.
    -   Emit Approval event.

## Nuance & Risks
1.  **Front-running**: The signature is visible in the mempool and can be submitted by anyone. This is **harmless** because the result is the same: the approval is set.
2.  **Replay Attacks**:
    -   **Cross-Chain**: DOMAIN_SEPARATOR includes chainId to prevent a signature on one chain from being used on another.
    -   **Same-Chain**: nonces prevent using the same signature twice.
3.  **Zero Address**: ecrecover returns address(0) for invalid signatures. A check for signer != address(0) is required to prevent approving funds for the zero address.
4.  **Deadline**: Essential for security. Ensures signatures do not remain valid indefinitely if not submitted.

## Summary Comparison
-   **ERC-20**: Requires approve() transaction (ETH + Gas) before usage.
-   **ERC-2612**: Allows permit() via signature (No ETH, Gas paid by Relayer). Enables 1-tx flows.
