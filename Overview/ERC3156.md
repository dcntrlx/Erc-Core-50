# ERC3156
Created: 2020-11
Description: A standard interface for single-asset flash loans. It defines interfaces for lenders to accept flash loan requests and for borrowers to receive the loan, execute logic, and repay it within the same transaction.

## Methods

### Lender Methods
1. flashLoan
   ```solidity
   function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes calldata data) external returns (bool);
   ```
   Initiates a flash loan.
   - Transfers `amount` of `token` to `receiver`.
   - Calls `receiver.onFlashLoan`.
   -Must to approve `amount + fee` back from `receiver`.
   - Returns `true` if successful.

2. maxFlashLoan
   ```solidity
   function maxFlashLoan(address token) external view returns (uint256);
   ```
   Returns the maximum amount of `token` available to be lent. Returns 0 if token is not supported.

3. flashFee
   ```solidity
   function flashFee(address token, uint256 amount) external view returns (uint256);
   ```
   Returns the fee charged for a loan of `amount` `token`. Reverts if token is not supported.

### Borrower Interface
1. onFlashLoan
   ```solidity
   function onFlashLoan(address initiator, address token, uint256 amount, uint256 fee, bytes calldata data) external returns (bytes32);
   ```
   Called by the Lender during `flashLoan`.
   - `initiator`: The address that called `flashLoan`.
   - `token`: The token being lent.
   - `amount`: The amount lent.
   - `fee`: The fee to be repaid.
   - `data`: Arbitrary data passed from `flashLoan`.
   - MUST return `keccak256("ERC3156FlashBorrower.onFlashLoan")` to accept.
   - MUST approve `amount + fee` to the Lender before returning.

## Implementation

### Lender Side
Transfers tokens, calls callback, and pulls repayment.
```solidity
function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes calldata data) external returns (bool) {
    uint256 fee = flashFee(token, amount);
    // 1. Transfer tokens to receiver
    require(IERC20(token).transfer(address(receiver), amount), "Transfer failed");
    
    // 2. Call receiver
    require(
        receiver.onFlashLoan(msg.sender, token, amount, fee, data) == keccak256("ERC3156FlashBorrower.onFlashLoan"),
        "Callback failed"
    );

    // 3. Pull repayment
    require(IERC20(token).transferFrom(address(receiver), address(this), amount + fee), "Repayment failed");
    
    return true;
}
```

### Borrower Side
Receives tokens, uses them, and approves repayment.
```solidity
function onFlashLoan(address initiator, address token, uint256 amount, uint256 fee, bytes calldata data) external returns (bytes32) {
    require(msg.sender == address(lender), "Untrusted lender");
    require(initiator == address(this), "Untrusted initiator"); // Optional: if you only want to initiate your own loans

    // 1. Use the tokens (Arbitrage, Liquidation, etc.)
    // 2. Approve repayment
    IERC20(token).approve(address(lender), amount + fee);
    
    return keccak256("ERC3156FlashBorrower.onFlashLoan");
}
```

## Nuance & Risks
1. **Callback Verification**: The Lender MUST verify `onFlashLoan` returns the correct magic value. If not, it must revert. This prevents accidental draining of contracts that might have open approvals but aren't flash loan receivers.
2. **Untrusted Initiator**: A Borrower should check `initiator` in `onFlashLoan`. If anyone can call `flashLoan` with your contract as the receiver, they could force your contract to take a loan and pay fees, draining your funds.
3. **Reentrancy**: Flash loans are inherently reentrant. Lenders should use ReentrancyGuard.

## Conclusion
- **ERC-3156**: Standardized `flashLoan` and `onFlashLoan` names, explicit `initiator` passing, standardized return values.
