# [ERC1822](https://eips.ethereum.org/EIPS/eip-1822)
**Created:** 2019-03-04

**Description:** AUUPS (Universal Upgradeable Proxy Standard) - standard for upgradeable proxies where the upgrade logic resides in the implementation contract, not the proxy.

### Overview
ERC-1822 defines a "Universal Upgradeable Proxy Standard" (UUPS). Unlike traditional proxies that hold the upgrade logic themselves, UUPS proxies are "thin clients"—they only contain a `delegatecall` fallback. The logic for upgrading the contract (changing the implementation address) is contained within the **implementation contract itself**. The implementation upgrades itself. To prevent upgrading to a contract that cannot upgrade further the standard includes a compatibility check.

UUPS vs older Transparent Proxies
#### 1. The Inversion of Control
*   **Transparent Proxy (Old Way):** The Proxy is the boss. It holds the `upgradeTo` function and an `admin` address. The implementation is just a library of code.
*   **ERC-1822 (UUPS Way):** The Proxy is a dumb pipe. The *Implementation* holds the `upgradeTo` function. The implementation upgrades *itself*.

#### 2. The "Proxiable" UUID (The Safety Handshake)
Because the proxy is "dumb," it blindly delegates everything. If you upgrade to a new implementation that *doesn't* have an upgrade function, you are stuck forever.

ERC-1822 solves this with a handshake:
1.  The Proxy checks if the new implementation is UUPS
2.  The new implementation must return a specific UUID (Unique Universal ID)—usually the storage slot of the implementation contract' address
3.  If the ID matches, the upgrade proceeds. If it reverts or returns the wrong ID, the upgrade fails.

#### 3. Gas Efficiency
Because the Proxy doesn't need to check "Is the caller the admin?" on every single function call (which Transparent Proxies must do to avoid function selector clashes), ERC-1822 proxies are significantly cheaper to use for end-users.

Strict ERC-1822 suggests using keccak256("PROXIABLE") as the storage slot for the implementation address. However, the industry standard  actually uses the **ERC-1967** storage slot (keccak256("eip1967.proxy.implementation") - 1). Thus we ussually use 1822 with 1967 storage slots.

**3. Initializers are Tricky**
Since the constructor code in the implementation contract is never executed in the context of the proxy's storage, you must use an initialize() function. If you leave this function unprotected, or if you forget to call it atomically during deployment (using upgradeToAndCall), an attacker could initialize your contract before you do.

### Specification Interface
The standard defines a specific interface for the implementation contract to ensure compatibility.

1.  **updateCodeAddress**
    ```solidity
    function updateCodeAddress(address newAddress) external;
    ```
    Updates the proxy's logic contract to `newAddress`. This function must check that `newAddress` implements the `proxiableUUID` function and returns the correct UUID.

2.  **proxiableUUID**
    ```solidity
    function proxiableUUID() external view returns (bytes32);
    ```
    Returns the compatibility ID. This is typically the storage slot where the implementation address is stored.
    - **Value (Strict 1822)**: `0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7` (keccak256("PROXIABLE")).
    - **Value (OpenZeppelin/ERC-1967)**: `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc` (keccak256("eip1967.proxy.implementation") - 1).

    *Note: Most modern implementations use the ERC-1967 value to ensure tooling compatibility.*
