# ERC7683
Created: 2024-04
Description: A standard interface for Cross-Chain Intents, allowing users to sign a generic order that can be filled by any solver on any chain.

ERC-7683 defines a standard `CrossChainOrder` struct and a standard `IOriginSettler` interface.
1.  Unified Order Format: Solvers can parse orders from any app that uses this standard.
2.  Shared Liquidity: A solver network can service multiple applications without custom integration for each.
3.  Intent-Based: The user specifies what they want (e.g., "I want 100 USDC on Arbitrum"), not how to get it.

## Methods

### Order Structs
The standard defines two main structs:
1.  GaslessCrossChainOrder: Signed off-chain by the user. Contains `nonce`, `openDeadline`, `fillDeadline`, and `orderData`.
2.  OnchainCrossChainOrder: Created by the user calling a contract directly.

### Settlement Interface
```solidity
interface IOriginSettler {
    // For gasless orders (User signs, Filler submits)
    function openFor(GaslessCrossChainOrder calldata order, bytes calldata signature, bytes calldata originFillerData) external;

    // For on-chain orders (User submits)
    function open(OnchainCrossChainOrder calldata order) external;

    // View function to parse the opaque 'orderData'
    function resolveFor(GaslessCrossChainOrder calldata order, bytes calldata originFillerData) external view returns (ResolvedCrossChainOrder memory);
}
```

### Resolved Order
The `resolveFor` function is critical. It converts the protocol-specific `orderData` into a generic `ResolvedCrossChainOrder` that any solver can understand:
```solidity
struct ResolvedCrossChainOrder {
    address user;
    uint256 originChainId;
    uint32 fillDeadline;
    Output[] maxSpent;     // What the user gives
    Output[] minReceived;  // What the user wants
    FillInstruction[] fillInstructions; // How to fill it
}
```

## Implementation Details

### The Flow
1.  User signs a `GaslessCrossChainOrder` on Chain A (Origin).
2.  Solver sees the order, calls `resolveFor` to understand the requirements (e.g., "User gives 1 ETH on Chain A, wants 3000 USDC on Chain B").
3.  Solver calls `openFor` on Chain A to initiate the trade (escrowing user funds).
4.  Solver fulfills the order on Chain B (Destination) using the `fillInstructions`.
