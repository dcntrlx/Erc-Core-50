# ERC2535
Created: 2020-02

Description: The "Diamond" Standard. A  proxy standard that allows building modular, upgradeable smart contract systems that can exceed the 24KB size limit. It enables a single contract address to delegate calls to multiple implementation contracts (Facets).

## Core Concepts

### The Diamond Analogy
- **Diamond**: The main proxy contract that users interact with. It holds the state (storage) and money.
- **Facets**: The "sides" of the diamond. Separate implementation contracts that contain the logic. The Diamond borrows their code via `delegatecall`.
- **Cut**: The action of adding, replacing, or removing Facets (upgrading).
- **Loupe**: A special Facet that provides "introspection" (allows you to look into the Diamond to see what functions it supports).

### Why use it?
1.  **Bypass Size Limit**: Break a huge contract into many small Facets.
2.  **Modular Upgrades**: Upgrade just one small part (Facet) of your system without redeploying everything.
3.  **Single Address**: Users interact with one address, even if the logic is split across 20 contracts.

## Architecture



### Storage Layout (Diamond Storage)
Since many Facets share the same storage space (the Diamond's storage), collisions are a risk. If Facet A writes to `slot 0` and Facet B also writes to `slot 0`, they will corrupt each other's data.

**The Solution: Namespaced Storage**
Instead of letting Solidity pick the slot (0, 1, 2...), we force our variables to live at a random, collision-resistant location.
1.  Defining a `struct` containing **all state variables**.
2.  Picking a unique string (e.g., "com.myproject.storage.user").
3.  Hashing it to get a random slot: `keccak256("com.myproject.storage.user")`.
4.  Using assembly to tell Solidity: "My struct lives at THIS specific slot."
**ALL state varibales live in the same struct(for single fascet)**

**Upgrading Storage**:
Since Facets are immutable, wecant a deployed struct. To add state variables:
1.  **Define**: Create FacetV2 with an updated struct (appending new fields to the end).
2.  **Deploy**: Deploy FacetV2 to the blockchain.
3.  **Cut**: Use diamondCut to replace FacetV1 with FacetV2.
The Proxy holds the raw bytes; the new Facet provides the updated "lens" to interpret them (reading old a and new b).

Upgrading storage is rare operation. To compare to standard smart contract, something like this required when we upgrade the contract via proxy

#### Note on ERC7201
This pattern was later standardized and improved by ERC7201 (Namespaced Storage Layout), which defines a strict formula for the slot calculation to ensure compatibility with future Ethereum upgrades (Verkle Trees) and tooling.

## Methods & Interfaces

### 1. IDiamondCut (The "Cut")
Standard interface for upgrading the Diamond.
```solidity
interface IDiamondCut {
    enum FacetCutAction { Add, Replace, Remove }

    struct FacetCut {
        address facetAddress;
        FacetCutAction action;
        bytes4[] functionSelectors;
    }

    function diamondCut(
        FacetCut[] calldata _diamondCut,
        address _init,
        bytes calldata _calldata
    ) external;
}
```
-   `_diamondCut`: List of changes (Add/Replace/Remove functions).
-   `_init` & `_calldata`: Optional "initializer" function to run after the cut (e.g., to set initial state variables).

### 2. IDiamondLoupe (The "Loupe")
Standard interface for introspection. Tools (Etherscan, Louper) use this to display the Diamond's verified source code.
```solidity
interface IDiamondLoupe {
    // Get all facets and their selectors
    function facets() external view returns (Facet[] memory);
    
    // Get all selectors for a specific facet
    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory);
    
    // Get all facet addresses
    function facetAddresses() external view returns (address[] memory);
    
    // Find which facet handles a specific function
    function facetAddress(bytes4 _functionSelector) external view returns (address);
}
```

## Implementation

### The Fallback
When an external function is called on a diamond its fallback function is executed. The fallback function determines which facet to call based on the first four bytes of the call data (known as the function selector) and executes that function from the facet using `delegatecall`.

A diamond’s fallback function and `delegatecall` enable a diamond to execute a facet’s function as if it was implemented by the diamond itself. The `msg.sender` and `msg.value` values do not change and only the diamond’s storage is read and written to.

Fallback implementation (From EIP directly)

```solidity
// Find facet for function that is called and execute the
// function if a facet is found and return any value.
fallback() external payable {
  // get facet from function selector
  address facet = selectorTofacet[msg.sig];
  require(facet != address(0));
  // Execute external function from facet using delegatecall and return any value.
  assembly {
    // copy function selector and any arguments
    calldatacopy(0, 0, calldatasize())
    // execute function call using the facet
    let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)
    // get any return value
    returndatacopy(0, 0, returndatasize())
    // return any return value or error back to the caller
    switch result
      case 0 {revert(0, returndatasize())}
      default {return (0, returndatasize())}
  }
}
```

## Risks
1. Today ERC7201 namespaced storage should be used instead of Diamond Storage.
2. Must prevent function's selectors collisions