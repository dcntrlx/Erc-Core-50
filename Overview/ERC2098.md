# [ERC2098](https://eips.ethereum.org/EIPS/eip-2098)
**Created:** 2019-03-14
**Description:** A standard for a compact representation of Ethereum signatures.
- Reduces signature size from 65 bytes to 64 bytes.
- Saves gas and storage by fitting the signature into exactly two 32-byte words.

### Core Concept: The 64-Byte Squeeze
Standard ECDSA signatures in Ethereum consist of three parts:
1.  `r` (32 bytes)
2.  `s` (32 bytes)
3.  `v` (1 byte, usually 27 or 28)

Total = 65 bytes.
In Solidity, this often requires 96 bytes (three 32-byte words) to store, or complex byte manipulation.

ERC-2098 observes that:
1.  `v` is effectively a 1-bit value (0 or 1, representing y-parity).
2.  The top bit of `s` is **always 0** in valid Ethereum signatures (due to EIP-2 restrictions preventing malleability).

**The Trick:**
We can store `v` in that unused top bit of `s`.
- `r` remains 32 bytes.
- `vs` = `(v << 255) | s` (32 bytes).

Total = 64 bytes.

### Top Bit of `s` is Always 0
The top bit is guaranteed to be zero due to a consensus rule (EIP-2) designed to prevent **Signature Malleability**.

1.  **The Problem**: In standard ECDSA, for any valid signature `(r, s)`, the signature `(r, n - s)` is also valid. This allows attackers to flip the bits and create a different transaction hash for the same payload.
2.  **The Fix (EIP-2)**: Ethereum enforces that `s` must be in the **lower half** of the curve order (`s <= n/2`).
3.  **The Math**: Since the curve order `n` is slightly less than `2^256`, `n/2` is slightly less than `2^255`.
4.  **The Result**: Any valid `s` uses at most 255 bits. The 256th bit (the most significant bit) is **always 0**.
5.  **The Opportunity**: ERC-2098 hijacks this guaranteed zero bit to store the 1-bit `v` value (y-parity).

### Specification
A compact signature is represented as two 32-byte values:
1.  `r`: The x-coordinate of the curve point.
2.  `vs`: The s-value with the y-parity bit stored in the most significant bit.

#### Encoding (Creating Compact Sig)
```solidity
bytes32 r = ...;
bytes32 s = ...;
uint8 v = ...; // 27 or 28

// 1. Normalize v to 0 or 1
uint8 yParity = v - 27;

// 2. Pack yParity into the top bit of s
bytes32 vs = s | (bytes32(uint256(yParity)) << 255);

// Result: r, vs
```

#### Decoding (Verifying Compact Sig)
```solidity
bytes32 r = ...;
bytes32 vs = ...;

// 1. Extract yParity (top bit)
uint8 yParity = uint8(uint256(vs) >> 255);
uint8 v = yParity + 27;

// 2. Clear top bit to get original s
bytes32 s = vs & 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;

// 3. Verify using ecrecover(hash, v, r, s)
```

### Motivation
1.  **Gas Efficiency**: Storing 64 bytes (2 slots) is cheaper than 65+ bytes (3 slots or dynamic bytes).
2.  **EVM Alignment**: The EVM works with 32-byte words. A 64-byte signature fits perfectly into two stack items or two storage slots.
3.  **Transaction Size**: Reduces calldata size, which saves gas (especially on Rollups).

### Implementation
Many libraries support this out of the box.
- **OpenZeppelin**: `ECDSA.sol` has `tryRecover` overloads that accept `bytes32 r, bytes32 vs`.
- **Ethers.js**: Supports compact signatures internally.

### Mental Model: The "Zip File" for Signatures
Think of ERC-2098 as a "zip" format for signatures.
- **Standard**: `[r] [s] [v]` (Loose files, takes up extra space).
- **Compact**: `[r] [vs]` (Zipped, fits perfectly in the box).

### Nuance and Edge Cases
1.  **Malleability**: Just like standard signatures, you must ensure `s` is in the lower half of the curve order. ERC-2098 relies on this fact to use the top bit.
2.  **Compatibility**: Not all wallets produce compact signatures by default. You often need to convert them on the client side or in the contract.
