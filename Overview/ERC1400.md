# ERC1400
Created: 2018-09
Description: A comprehensive "Security Token Standard" that aggregates multiple standards to handle complex regulatory requirements like partitions, document management, and forced transfers.

## Core Concepts

### The Problem: Regulatory Compliance
Real-world securities (stocks, bonds) have complex legal requirements that ERC-20 cannot handle:
-   **Differentiation**: Some tokens are "vested", some are "unrestricted". ERC-20 treats all tokens as identical (fungible).
-   **Compliance**: Transfers often require on-chain validation (KYC/AML checks).
-   **Legal Oversight**: Issuers may need to force-transfer tokens (e.g., court orders, lost keys).
-   **Documentation**: Investors need access to legal documents (prospectus, terms).

### The Solution: A Library of Standards
ERC-1400 is an umbrella standard that combines four specific modules to solve these problems:
1.  **ERC-1410 (Partitions)**: Splits a user's balance into "tranches" (e.g., "Vested", "Free").
2.  **ERC-1594 (Core)**: Adds `canTransfer` checks and `transferWithData`.
3.  **ERC-1643 (Documents)**: Manages legal documents on-chain.
4.  **ERC-1644 (Controller)**: Allows forced transfers by a trusted controller.

## Methods

### Token Information & Partitions (ERC-1410)
```solidity
function balanceOfByPartition(bytes32 partition, address tokenHolder) external view returns (uint256);
function partitionsOf(address tokenHolder) external view returns (bytes32[]);
```
-   **partition**: A `bytes32` identifier for the tranche (e.g., hash of "VESTED_2024").
-   **balanceOfByPartition**: Returns the balance within a specific partition.

### Transfers & Validity (ERC-1594)
```solidity
function transferWithData(address to, uint256 value, bytes data) external;
function canTransfer(address to, uint256 value, bytes data) external view returns (byte, bytes32);
```
-   **transferWithData**: Like ERC-20 transfer but includes extra data for compliance checks.
-   **canTransfer**: Checks *if* a transfer would succeed and returns a reason code if not.

### Controller Operations (ERC-1644)
```solidity
function controllerTransfer(address from, address to, uint256 value, bytes data, bytes operatorData) external;
function isControllable() external view returns (bool);
```
-   **controllerTransfer**: Allows the controller to move tokens without the owner's permission (for legal recovery).

### Document Management (ERC-1643)
```solidity
function setDocument(bytes32 name, string uri, bytes32 documentHash) external;
function getDocument(bytes32 name) external view returns (string, bytes32);
```
-   Links legal documents (PDFs) to the token via a URI and hash.

## Implementation Details

### Partitions
Instead of a simple `mapping(address => uint256) balances`, ERC-1400 uses a nested mapping:
`mapping(address => mapping(bytes32 => uint256)) partitionBalances`.
The standard ERC-20 `balanceOf(user)` returns the **sum** of all partitions for that user.

### The "Controller"
The Controller is a powerful role (often the Issuer or a Regulator).
-   **Power**: Can burn or move tokens at will.
-   **Transparency**: All controller actions MUST emit specific events (`ControllerTransfer`, `ControllerRedemption`) so the network knows a forced action occurred.

## Nuance & Risks
1.  **Centralization**: The Controller role implies a high degree of trust. This is a feature (for securities), not a bug, but it differs from the "code is law" ethos of DeFi.
2.  **Complexity**: Implementing all four sub-standards makes the contract large and complex.
3.  **Backwards Compatibility**: ERC-1400 is fully backwards compatible with ERC-20. Legacy wallets see the total balance, while aware wallets see the partitions.

## Summary Comparison
-   **ERC-20**: Simple, fully fungible, censorship-resistant (usually).
-   **ERC-1400**: Complex, partially fungible (partitions), controllable (forced transfers), and compliance-ready.
