# [ERC7201](https://eips.ethereum.org/EIPS/eip-7201)
Created: 2023-06-20
Description: A standard for Namespaced Storage Layouts. It provides a formalized, collision-safe method to organize where variables are kept in a smart contract's store

### Overview
ERC7201 defines a formula to calculate a specific, safe storage "root" for a group of variables. Instead of letting Solidity automatically place variables in slot 0, 1, 2, etc we force a specific set of variables to live at a random, dedicated slot.

This is critical for upgradeable contracts and proxies to prevent Storage Collisionsâ€”where a new version of a contract accidentally overwrites data from an old version or a parent contract.

### Technical Implementation
To implement ERC7201, we don't declare state variables normally. Instead, we wrap them in a struct and use assembly to force that struct to live at a specific location.

#### The Formula
The standard defines the location as:
Slot = keccak256(keccak256(namespace_id) - 1) & ~0xff

- namespace_id: A unique string (e.g., example.main).
- - 1: Prevents collision with standard mappings.
- & ~0xff: Clears the last byte, aligning the storage to check for future Verkle tree compatibility (gas optimization).
- **Subsequent Values**: Once the "root" slot is determined for the struct, Solidity automatically handles the offsets for the fields inside.
  - `struct.field1` is at `root + 0`
  - `struct.field2` is at `root + 1` (or packed into `root + 0` if small enough)
  - `struct.field3` is at `root + 2`

#### Code Example (Solidity 0.8.20+)
You must use the @custom:storage-location NatSpec tag so tooling (like OpenZeppelin Upgrades) knows where to look.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract MyContract {
    /// @custom:storage-location erc7201:example.main
    struct MainStorage {
        uint256 x;
        uint256 y;
    }

    // keccak256(abi.encode(uint256(keccak256("example.main")) - 1)) & ~bytes32(uint256(0xff))
    bytes32 private constant MAIN_STORAGE_LOCATION =
        0x183a6125c38840424c4a85fa12f5c9688633406742ca3a5499f160124e930900;

    function _getMainStorage() private pure returns (MainStorage storage $) {
        assembly {
            $.slot := MAIN_STORAGE_LOCATION
        }
    }

    function setX(uint256 _x) external {
        MainStorage storage $ = _getMainStorage();
        $.x = _x;
    }
    
    function getX() external view returns (uint256) {
        MainStorage storage $ = _getMainStorage();
        return $.x;
    }
}
```

### Pros
1. Upgrade Safety: You can reorder logic contracts or inherit from new contracts without shifting the storage slots of existing variables.
2. Diamond/Proxy Compatibility: Multiple facets (implementation contracts) can access their own storage without stepping on each other's toes.
3. Tooling Support: Because it is a standard (ERC), tools like Hardhat and Foundry can automatically verify that your storage layout is safe during upgrades.

### Cons
- Gas Cost: Accessing storage this way is slightly more expensive in gas than standard variables because the compiler cannot optimize the slot calculation at compile time.
- Complexity: It requires using structs for everything and getter functions, which makes the code more verbose.
- Verkle Trees: The specific bitmask is forward-looking. It reserves a "page" of 256 slots, anticipating how Ethereum state proofs (Verkle Trees) will likely charge gas in the future.
