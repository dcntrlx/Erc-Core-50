# ERC6672

Created: 2023-03
Description: An extension for ERC-721 that enables multi-scenario redemptions  without burning the token.

## Core Concepts

### The Problem: Single-Use NFTs
Standard NFTs are often redeemed by burning them (sending to 0x00...0). This destroys the digital collectible.
Issue: If an NFT grants access to a physical T-shirt AND a concert ticket, burning it for the T-shirt destroys the ticket access.
Workaround: Centralized databases track who claimed what, but this is not trustless or interoperable.

### The Solution: Multi-Redeemable Status
ERC-6672 adds a standardized redemption layer on top of ERC-721.
1. Redemption Key: Redemptions are tracked by a unique combination of operator + tokenId + redemptionId.
2. No Burn: The token remains intact. Only its redemption status is updated on-chain.
3. Multiple Campaigns: Different operators (e.g., TicketMaster, Shopify) can manage their own redemption statuses for the same NFT independently.
4. Granular Utility (The Keychain): you redeem specific keys on the keychain.
   - Key #1 (ID: 1) -> Used for something 1
   - Key #2 (ID: 2) -> Still not used and can be usef for something 2
   - The Keychain (NFT) -> ont burned after usages of keys(only keys marked as used)

## Methods

### Redemption Management
```solidity
function redeem(uint256 tokenId, uint256 redemptionId, string memo) external;
function cancel(uint256 tokenId, uint256 redemptionId, string memo) external;
```
redeem: Marks a specific redemptionId as redeemed for the given token. Can only be called by the operator (the campaign manager).
cancel: Reverts the redemption status (e.g., if a physical order is cancelled).

### Status Views
```solidity
function isRedeemed(address operator, uint256 tokenId, uint256 redemptionId) external view returns (bool);
function getRedemption(address operator, uint256 tokenId, uint256 redemptionId) external view returns (bool status, string memo);
```
isRedeemed: Checks if a specific benefit has been claimed.

## Implementation Details

### The Key Structure
Redemption status is stored in a mapping keyed by a hash of three values:
Operator: The address managing the campaign (e.g., the event organizer).
TokenId: The specific NFT.
RedemptionId: A unique ID for the campaign (e.g., 1 = T-Shirt, 2 = Ticket).

This ensures that Operator A's T-Shirt redemption doesn't conflict with Operator B's Ticket redemption.

### Metadata Extension
The standard includes a tokenURI extension to expose redemption statuses in JSON format, allowing marketplaces to display Redeemed or Unredeemed badges dynamically.

## Nuance & Risks
1. Operator Trust: Users rely on the Operator to deliver goods after redeem() is called. Malicious operators can brick utility by flipping statuses.
2. Off-Chain Meaning: The chain only knows RedemptionID: 55 = True. The actual meaning (e.g., 55 = Gold Chain) relies on off-chain metadata/databases.
3. Gas Costs: On-chain status arrays are expensive on Mainnet; better suited for L2s.
