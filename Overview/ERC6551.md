# ERC-6551: Non-fungible Token Bound Accounts
Created: 2023-02-23

Description:
- Assigns a smart contract account to every ERC-721 NFT.
- Allows NFTs to own assets (tokens, other NFTs) and interact with dApps.
- Works without modifying existing NFT contracts.

Motivation: Give NFTs the full capabilities of an Ethereum user (identity, asset ownership, action execution).

## Core Concept: Token Bound Accounts (TBA)
Traditionally, an NFT is just a static asset owned by a wallet. ERC-6551 turns the NFT into a wallet.
- The NFT becomes the "key" or "controller".
- The Account (TBA) is the on-chain identity that holds assets.
- The Holder of the NFT controls the TBA.

## Architecture
The system consists of two main components:
1. Singleton Registry: A single, immutable contract deployed at a fixed address on all chains. It deploys TBAs.
2. Account Implementation: The logic for the TBA (how it executes transactions, validates signatures, etc.).

### The Registry
The Registry is permissionless and immutable. It uses `CREATE2` to deploy TBAs at deterministic addresses.

Registry Address: `0x000000006551c19487814612e58FE06813775758` (on all chains).

```solidity
interface IERC6551Registry {
    function createAccount(
        address implementation,
        bytes32 salt,
        uint256 chainId,
        address tokenContract,
        uint256 tokenId
    ) external returns (address account);

    function account(
        address implementation,
        bytes32 salt,
        uint256 chainId,
        address tokenContract,
        uint256 tokenId
    ) external view returns (address account);
}
```

### The Proxy Mechanism
The Registry deploys a Minimal Proxy (ERC-1167) that points to the `implementation` address.
Crucially, it appends immutable data to the proxy bytecode:
- `salt`
- `chainId`
- `tokenContract`
- `tokenId`

This allows the Account contract to know which NFT owns it by reading its own code.

## Account Interface
A compliant TBA must implement `IERC6551Account`.

```solidity
interface IERC6551Account {
    // Allows the account to receive Ether
    receive() external payable;

    // Returns the token that owns this account
    function token() external view returns (
        uint256 chainId,
        address tokenContract,
        uint256 tokenId
    );

    // Returns a state counter (changed on every successful execution)
    function state() external view returns (uint256);

    // Checks if a signer is valid (usually the owner of the NFT)
    function isValidSigner(address signer, bytes calldata context) external view returns (bytes4 magicValue);
}
```

## Execution Interface
To be useful, the account needs to execute transactions. This is standardized in `IERC6551Executable`.

```solidity
interface IERC6551Executable {
    function execute(
        address to,
        uint256 value,
        bytes calldata data,
        uint8 operation // 0 = CALL, 1 = DELEGATECALL, 2 = CREATE, 3 = CREATE2
    ) external payable returns (bytes memory);
}
```

## How It Works (The Flow)
1. Computation: Anyone can calculate the address of the TBA for a given NFT using `registry.account(...)`.
2. Deployment: The TBA is deployed via `registry.createAccount(...)`. This can be done lazily (only when needed).
3. Control:
    - The TBA checks `token()` to see which NFT owns it.
    - It calls `ERC721(tokenContract).ownerOf(tokenId)` to find the current holder.
    - It allows execution only if the caller is the current holder.

## Key Features
- Backward Compatible: Works with every ERC-721 ever deployed (CryptoPunks, BAYC, etc.).
- Cross-Chain: An NFT on Mainnet can own an account on Polygon (via the `chainId` parameter).
- Standardized: Wallets and dApps can automatically detect and display assets held by an NFT.
