# ERC7401
Created: 2022-11
Description: A standard for "Nestable" NFTs where one token can own another, creating parent-child relationships governed by the parent's owner. Supersedes ERC-6059.

## Core Concepts

### The Problem: Isolated Assets
Standard ERC-721 tokens are isolated. A "Game Character" NFT and a "Sword" NFT are just two separate tokens in a wallet. There is no on-chain link between them. You cannot "equip" the sword to the character or sell them as a single bundle easily.

### The Solution: Nesting & Parent Governance
ERC-7401 allows an NFT to own other NFTs.
1.  **Nesting**: Token B (Child) is transferred to Token A (Parent).
2.  **Parent Governance**: The owner of Token A automatically has full control over Token B. If Token A is sold, Token B goes with it.
3.  **Propose-Commit**: To prevent spam if someone sending junk NFTs to high-value NFT new children are placed in a "Pending" array and must be explicitly Accepted by the parent's owner.

## Methods

### Child Management
```solidity
function addChild(uint256 parentId, uint256 childId, bytes data) external;
function acceptChild(uint256 parentId, uint256 childIndex, address childAddress, uint256 childId) external;
function transferChild(uint256 tokenId, address to, uint256 destinationId, uint256 childIndex, address childAddress, uint256 childId, bool isPending, bytes data) external;
```
-   **addChild**: Proposes a child token to a parent.
-   **acceptChild**: Moves a child from "Pending" to "Active".
-   **transferChild**: Moves a child out of the parent (to a wallet or another NFT).

### Ownership Views
```solidity
function ownerOf(uint256 tokenId) external view returns (address);
function directOwnerOf(uint256 tokenId) external view returns (address owner, uint256 parentId, bool isNft);
```
-   **ownerOf**: Recursively climbs the tree until it finds an EOA or Contract (the "Root Owner").
-   **directOwnerOf**: Returns the immediate parent (which might be another NFT).

## Implementation Details

### The Pending Queue
When a token is sent to another NFT (via `nestTransferFrom`), it enters the `pendingChildren` array.
-   **Limit**: The pending array should be capped (e.g., 128 slots) to prevent griefing attacks where an attacker fills the array with garbage.
-   **Acceptance**: Only the Root Owner can call `acceptChild` to move it to the `activeChildren` array.

### Recursive Ownership
The `ownerOf` function is recursive:
1.  Check direct owner of Token C. -> It's Token B.
2.  Check direct owner of Token B. -> It's Token A.
3.  Check direct owner of Token A. -> It's User Alice.
4.  Return Alice.

## Nuance & Risks
1.  **Circular Ownership**: The contract must prevent loops (A owns B, B owns A). This would lock the tokens forever.
2.  **Gas Costs**: Deeply nested chains increase the gas cost of `ownerOf` lookups.
3.  **Marketplace Compatibility**: Standard marketplaces might not see the nested children. They only see the Parent. Selling the Parent sells the entire tree.

## Comparison: ERC-7401 vs ERC-6551
1.  **Architecture & Awareness**: ERC-6551 is a **Wallet** (Parent is oblivious to contents). ERC-7401 is a **Relation** (Parent explicitly stores `activeChildren`). 7401 allows on-chain logic like `if (hero.hasSword)` without external indexing.
2.  **Equipping**: ERC-6551 is "Logic Layer" (requires external app state to know if a sword is held or just in the bag). ERC-7401 is "Protocol Layer" (often used with ERC-6220 to enforce slots like "Left Hand" on-chain).
